Fun code is in the source folder.

If you modify ccluster.pyx, be sure to rebuild using:
```
python ccluster-helper.py build_ext --inplace
```

To see what uses python, execute the below command and open ccluster.html in the source directory. 
```
cython ccluster.pyx -a
```
Python dense areas will he highlighted yellow.


Will generate a (semi-sparce) 67+ gb numpy matrix.

Elements can be accessed using two mappings. One maps your hand to a particular chunk. The other maps the board to an index within the chunk. This scales and will be more intuitive when you see it. Point being that element access is not quite O(1)... but most nearly.

Current stats project an ~3 hour runtime to generate exact hand strength calculations for the river on an 8 core system assuming 64+ gigs of ram. Without 64+ gigs of ram, you will need to split the work into a number of futures processes s.t. you at no point run out of memory while the program is running. A better alternative is writing to a /var/swapfile on an SSD with decent speeds (as long as you're not writing from 64 workers...). Ordered chunks labed by id # will be autogenerated and output to 'src/reports/'. These chunks are (currently) based on the number of futures processes selected. Increasing the concurrent futures count beyond the number of threads on your system you will reduce runtime your overall runtime because of cpu work loads being stacked.

On my desktop (AMD Ryzon 7 3700x, 16gb ram w/128gb swap) with the work split across 16 threads the total run time is cut down to just over 30 minutes. The process can be fully completed locally with no need for AWS or Google VMs.

Looking for a kmeans++ clustering algorithm written in c/cython to cluster river, turn, and flop datasets. 


Similar logic can be applied to the turn and flop datasets while referencing the river dataset for twl (tie win loss) stats. Parallelism will need to be done using prange in cython as we will only be able to store one river dataset in memory at a time.