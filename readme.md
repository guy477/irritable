Fun code is in the source folder.

If you modify ccluster.pyx, be sure to rebuild using:
```
python ccluster-helper.py build_ext --inplace
```

To see what uses python, execute the below command and open ccluster.html in the source directory. 
```
cython ccluster.pyx -a
```
Python dense areas will he highlighted yellow.


Will generate a (semi-sparce) 50+ gb numpy matrix.

Elements can be accessed using two mappings. One maps your hand to a particular chunk. The other maps the board to an index within the chunk. This scales and will be more intuitive when you see it. Point being that element access is not quite O(1)... but most nearly.

Current stats project an ~3 hour runtime to generate exact hand strength calculations for the river on an 8 core system assuming 64+ gigs of ram. Without 64+ gigs of ram, you will need to split the work into a number of futures processes s.t. you at no point run out of memory while the program is running. Ordered chunks labed by id # will be autogenerated and output to 'src/reports/'. Increasing the concurrent futures count will reduce runtime if your cpu work loads begin stacking.

On my desktop (AMD Ryzon 7 3700x, 16gb ram w/128gb swap) with the work split across 16 threads the total run time is cut down to just over 30 minutes. The process can fully be completed locally with no need for AWS or Google VMs. 

Looking for a kmeans++ clustering algorithm written in c/cython to cluster river, turn, and flop datasets. 


The same logic can be applied to the turn and flop datasets while referencing the river dataset for twl (tie win loss) stats. Parallelism will need to be done using prange in cython as we will only be able to store one river dataset in memory at a time.